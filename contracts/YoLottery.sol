//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";
import "https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/VRFConsumerBaseV2.sol";
import "https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/LinkTokenInterface.sol";

// import "hardhat/console.sol";
contract PoolCreator is VRFConsumerBaseV2 { 
    /* Variables */
    mapping(address => Pool) PoolData;
    address owner;

    /* VRF2 variables */
    VRFCoordinatorV2Interface COORDINATOR;
    LinkTokenInterface LINKTOKEN;

    // Rinkeby coordinator
    address vrfCoordinator = 0x6168499c0cFfCaCD319c818142124B7A15E857ab;

    // Rinkeby LINK token contract
    address link_token_contract = 0x01BE23585060835E02B77ef475b0Cc51aA1e0709;

    /* Modifiers */
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    constructor() VRFConsumerBaseV2(vrfCoordinator) {
        
        COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
        LINKTOKEN = LinkTokenInterface(link_token_contract);
        owner = msg.sender;
    }

    /* VRF functions */
    function topUpSubscription(uint64 _subscriptionId, uint256 _amount) external onlyOwner {
        LINKTOKEN.transferAndCall(address(COORDINATOR), _amount, abi.encode(_subscriptionId));
    }

    function addConsumer(uint64 _subscriptionId, address _consumerAddress) external onlyOwner {
        COORDINATOR.addConsumer(_subscriptionId, _consumerAddress);
    }

    function removeConsumer(uint64 _subscriptionId, address _consumerAddress) external onlyOwner {
        COORDINATOR.removeConsumer(_subscriptionId, _consumerAddress);
    }

    function cancelSubscription(uint64 _subscriptionId, address _receivingWallet) external onlyOwner {
        COORDINATOR.cancelSubscription(_subscriptionId, _receivingWallet);
    }

    function withdrawLinkToken(uint256 amount, address to) external onlyOwner {
        LINKTOKEN.transfer(to, amount);
    }

    function createPool(uint _buyLimit, uint _timeInterval, uint64 _subscriptionId) external onlyOwner {      
        Pool newPool = new Pool(owner, _buyLimit, _timeInterval, _subscriptionId); 
        PoolData[address(newPool)] = newPool;
        COORDINATOR.addConsumer(_subscriptionId, address(newPool));
    }

    function removePool(address payable _poolAddress, uint64 _subscriptionId) external onlyOwner {
        Pool existingPool = Pool(_poolAddress);
        COORDINATOR.removeConsumer(_subscriptionId, _poolAddress);
        existingPool.closeContract();
        delete PoolData[_poolAddress];
    }

    // Needed in order for inherit to work
    function fulfillRandomWords(
        uint256,
        uint256[] memory randomWords
    ) internal override {}
}

/*
    TODO: 
    1. Create a pool that people can put money in -> X
    - the pool is created by the PoolCreator which also contains specific parameters that are passed in
        - Params: time interval, buy in limit, address of creator
        - How to separate pools of different currencies?
            - Important so that the pools can be deleted
    - Just work on simple case for now...
        - Each pool has: balances of contributors to the pool, balances amount of tickets, total amount contributed to the pool/total number of tickets purchased, buy in limit 
    2. Transfer money in and out of pool -> X
    - https://solidity-by-example.org/sending-ether/
    - money will be stored in contract as ETH in this case
    - use call
    3. Randomize distribution of funds -> X
    - use block numbers + timestamp + amount of tickets for randomization
    4. Unlock pool after some time interval -> X
    - distributeFunds function, anyone can call and it will unlock. User is rewarded for unlocking pool
    5. Change types to optimal values -> WIP
    6. Add modifiers -> WIP
    7. Start pool 
    - minimum buy in minimum total pool -> X
    8. Starting pool parameters -> X
    10. Support ERC20 token (USDT) -> WIP inherit different tokens -> the creator function can support the different pool types
    9. Add ticket system so fixed cost bets to get a ticket - each ticket gives a play in probability game
    10. Time release pool by letting user free it for small reward -> X
    11. Pool Creator & Pool Contracts -> WIP
    12. Emergency -> X
    Pools:
    - The balances of each participant in a pool will be recorded and it will be the users responsibility to pull out all funds for each pool accumulated to them... 

    Pool Creator:
    - The pool creator should manage the creation and destruction of pools
    - The pool will be generated by the pool creator. The pool creator will be able to generate pools corresponding to the different ERC20 tokens that exist

    to make more fair could iterate from first buyer to lower buyer, knowing first buyer has better odds of winning
    decrease the buy in fee by some number as the value goes down
*/ 

contract Pool is VRFConsumerBaseV2 {
    /* VRF Variables */
    VRFCoordinatorV2Interface COORDINATOR;

    // Rinkeby LINK
    address link_token_contract = 0x01BE23585060835E02B77ef475b0Cc51aA1e0709;

    // Subscription ID
    uint64 public s_subscriptionId;

    // Rinkeby coordinator
    address public vrfCoordinator = 0x6168499c0cFfCaCD319c818142124B7A15E857ab;

    // The gas lane to use, which specifies the maximum gas price to bump to
    bytes32 public keyHash = 0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc;

    // The default is 3, but you can set this higher.
    uint16 public requestConfirmations = 3;
    uint256[] public s_randomWords;
    uint256[] public randomWordsTest;
    uint256 public s_requestId;

    /* Variables */
    // TODO: Optimize space by making contiguous (256 bits)
    uint public buyLimit;
    uint public timeInterval;
    uint public startTime;
    uint public endTime;
    uint public ticketCap = 100000;
    uint32 public totalTickets;
    address public owner;
    bool internal locked;
    mapping(address => uint) public balances;
    mapping(address => uint) public ticketBalances;
    address[] public participants;

    enum State {Ready, Running, Canceled}
    State public poolState;

    /* Events */
    event StartPoolEvent(address sender, uint startTime, uint endTime);
    event BuyTicketEvent(address sender, uint amtTickets);
    event DistributePoolEvent(address sender, uint poolManagementFee, uint poolUnlockFee, uint poolPrize);
    event WithDrawEvent(address sender, uint owedFunds);

    /* Modifiers */ 
    modifier reentrancyGuard() {
        require(!locked, "The reetrancy guard has been triggered. Please try calling the function again.");
        locked = true;
        _;
        locked = false;
    }
    
    modifier poolOpen() {
        require(endTime >= block.timestamp, "The pool has not closed yet");
        _;
    }
    
    modifier poolClosed() {
        require(endTime < block.timestamp, "The pool has closed");
        _;
    } 

    modifier onlyOwner() {
        require(msg.sender == owner, "Only the owner can call this function");
        _;
    }

    /* Constructor */
    constructor(address _sender, uint _buyLimit, uint _timeInterval, uint64 _subscriptionId) VRFConsumerBaseV2(vrfCoordinator) {
        // VRF 
        COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
        s_subscriptionId = _subscriptionId;

        // Pool
        owner = _sender;
        buyLimit = _buyLimit;
        timeInterval = _timeInterval;        
        poolState = State.Ready;
    }

    /* VRF Functions */
    function requestRandomNumbers() public poolClosed {
        require(poolState == State.Running, "Pool must be in the running state");
        require(s_randomWords.length == 0, "Must populate random values first");

        uint32 callbackGasLimit = 20000; // 20000 per word is reasonable
        uint32 amountOfWords = 1;
        s_requestId = COORDINATOR.requestRandomWords(
            keyHash,
            s_subscriptionId,
            requestConfirmations,
            callbackGasLimit,
            amountOfWords
        );
    }

    // Set the subscripion Id
    function setSubcriptionId(uint64 _subscriptionId) public onlyOwner{
        s_subscriptionId = _subscriptionId;
    }

    // Get random values and do something with them
    function fulfillRandomWords(
        uint256,
        uint256[] memory randomWords
    ) internal override {
        s_randomWords = randomWords;
    }

    /* Functions */
    // Start running the pool
    function startPool() public onlyOwner {
        require(poolState == State.Ready, "Pool must be in the ready state");
        startTime = block.timestamp;
        endTime = startTime + timeInterval;
        poolState = State.Running;

        emit StartPoolEvent(msg.sender, startTime, endTime);
    }

    // Allow a user to buy a ticket
    function buyTicket() payable external poolOpen {
        require(poolState == State.Running, "Pool must be in the running state");
        require(msg.value >= buyLimit, "User must purchase tickets above the buying limit");
        require((msg.value % buyLimit) == 0, "User must purchase tickets at a multiple of the buy limit");
        require(totalTickets <= ticketCap, "Ticket cap has been reached");

        // TODO: Clean up types -> int32 casting
        // Get total amount of tickets
        uint amtTickets = msg.value / buyLimit;
        
        // Add user multiple times to participants array depending
        // on amount of tickets bought
        for (uint idx = 0; idx < amtTickets; idx++) {
            participants.push(msg.sender);
        }

        // Increase ticket count for address
        ticketBalances[msg.sender] += amtTickets;
        totalTickets += uint32(amtTickets);

        emit BuyTicketEvent(msg.sender, amtTickets);
    }
    
    // Generate random numbers from some seed value
    function randomNumberGenerator(uint seed) internal pure returns(uint) {
        uint modulus = seed % 10000;
        uint multiplier = 6782;
        uint increment = 8769;

        if (modulus == 0) {
            modulus = 1;
        }

        // TODO: confirm values since floats might make things go down to zero
        uint newSeed = (multiplier * seed + increment) % modulus;
        uint result = (newSeed * 100) / modulus;
        return result;
    }

    // Distribute funds in pool to all ticket holders
    function distributePool() public poolClosed {
        require(poolState == State.Running, "Pool must be in the running state");
        require(s_randomWords.length != 0, "Must populate random values first");
        address ticketOwner;

        // Allocate pool fees and prize
        // https://stackoverflow.com/questions/68310368/how-to-calculate-percentage-in-solidity
        uint poolBalance = address(this).balance;
        uint poolManagementFee = percentage(poolBalance, 3);
        uint poolUnlockFee = percentage(poolBalance, 1);
        uint poolPrize = percentage(poolBalance, 95);
        
        poolState = State.Ready;
        balances[msg.sender] += poolUnlockFee;

        // Distribute funds from pool to each participant
        // Take VRF2 seed number, right shift 1 bit (since value is 256 bits originally)
        // Use this number as a random seed for a number generator for probabilities
        // http://ntci.on.ca/compsci/tik/ch8/8_4.htm
        uint random_seed = s_randomWords[0] >> 1;
        uint random_number = 0;
        for (uint idx = 0; idx > (totalTickets - 1); idx++) {
            random_seed += idx;
            random_number = randomNumberGenerator(random_seed);
            ticketOwner = participants[idx];
            
            balances[ticketOwner] += percentage(poolPrize, random_number);
            delete ticketBalances[ticketOwner]; 
        }

        // Clear participants 
        delete participants;

        // Clear random values
        delete s_randomWords;

        // Clear tickets
        delete totalTickets;

        emit DistributePoolEvent(msg.sender, poolManagementFee, poolUnlockFee, poolPrize);
    }

    // Withdrawl all owed funds stored in balances
    function withdraw() payable external reentrancyGuard {
        uint owedFunds = balances[msg.sender];
        balances[msg.sender] = 0;
        (bool sent, bytes memory data) = msg.sender.call{value: owedFunds}("");
        require(sent, "Failed to send ether...");
        emit WithDrawEvent(msg.sender, owedFunds);
    }

    function closeContract() external onlyOwner {
        require(poolState == State.Canceled, "Pool must be in the canceled state");
        selfdestruct(payable(owner));
    }

    /* Emergency Functions */
    // Stop the pool in case of an emergency
    function emergencyStop() public onlyOwner {
        poolState = State.Canceled;
        address ticketOwner;

        // Give all funds back to users who purchased tickets in pool
        for (uint idx = 0; idx > (totalTickets - 1); idx++) {
            ticketOwner = participants[idx];
            balances[ticketOwner] += ticketBalances[ticketOwner] * buyLimit;
            delete ticketBalances[ticketOwner]; 
        }

        // Clear participants
        delete participants;
        delete totalTickets;
    }

    // Move pool out of emergency state and back to ready
    function emergencyReset() public onlyOwner {
        require(poolState == State.Canceled, "Pool must be in the canceled state");
        poolState = State.Ready;
    }

    /* Utility Functions */
    function percentage(uint value, uint pct) internal pure returns (uint256) {
        return (value / 100) * pct;
    }

    /* Getter and Setter Functions*/
    function getContractBalance() external view returns (uint) {
        return address(this).balance;
    }

    function getTicketBalance() external view returns (uint) {
        return ticketBalances[msg.sender];
    }

    function getBalance() external view returns (uint) {
        return balances[msg.sender];
    }

    function getPoolRunning() external view returns (bool) {
        return endTime >= block.timestamp;
    }

    // Function to receive Ether. msg.data must be empty
    receive() external payable {} 

    // Fallback function is called when msg.data is not empty
    fallback() external payable {}
}