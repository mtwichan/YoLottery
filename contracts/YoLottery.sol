//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

// import "hardhat/console.sol";

// contract PoolCreator { // Is this neccessary?
//     Pool[] public pools;

//     function createPool() public {
//         Pool newPool = new Pool(); // new pool connected to owner
//         pools.push(newPool);
//     }
// }

// only owner should be able to create pool
/*
    TODO: 
    1. Create a pool that people can put money in -> X
    - the pool is created by the PoolCreator which also contains specific parameters that are passed in
        - Params: time interval, buy in limit, address of creator
        - How to separate pools of different currencies?
            - Important so that the pools can be deleted
    - Just work on simple case for now...
        - Each pool has: balances of contributors to the pool, balances amount of tickets, total amount contributed to the pool/total number of tickets purchased, buy in limit 
    2. Transfer money in and out of pool -> X
    - https://solidity-by-example.org/sending-ether/
    - money will be stored in contract as ETH in this case
    - use call
    3. Randomize distribution of funds -> X
    - use block numbers + timestamp + amount of tickets for randomization
    4. Unlock pool after some time interval -> X
    - distributeFunds function, anyone can call and it will unlock. User is rewarded for unlocking pool
    5. Change types to optimal values -> WIP
    6. Add modifiers -> WIP
    7. Start pool 
    - minimum buy in minimum total pool -> X
    8. Starting pool parameters -> X
    10. Support ERC20 token (USDT) -> WIP inherit different tokens -> the creator function can support the different pool types
    9. Add ticket system so fixed cost bets to get a ticket - each ticket gives a play in probability game
    10. Time release pool by letting user free it for small reward -> X
    11. Pool Creator & Pool Contracts -> WIP
    12. Emergency -> X
    Pools:
    - The balances of each participant in a pool will be recorded and it will be the users responsibility to pull out all funds for each pool accumulated to them... 

    Pool Creator:
    - The pool creator should manage the creation and destruction of pools
    - The pool will be generated by the pool creator. The pool creator will be able to generate pools corresponding to the different ERC20 tokens that exist

    to make more fair could iterate from first buyer to lower buyer, knowing first buyer has better odds of winning
    decrease the buy in fee by some number as the value goes down
*/ 

import "https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";
import "https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/VRFConsumerBaseV2.sol";

contract Pool is VRFConsumerBaseV2 {
    /* VRF Variables */
    VRFCoordinatorV2Interface COORDINATOR;

    // Subscription ID
    uint64 public s_subscriptionId;

    // Rinkeby coordinator
    address public vrfCoordinator = 0x6168499c0cFfCaCD319c818142124B7A15E857ab;

    // The gas lane to use, which specifies the maximum gas price to bump to
    bytes32 public keyHash = 0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc;

    // The default is 3, but you can set this higher.
    uint16 public requestConfirmations = 3;
    uint256[] public s_randomWords;
    uint256[] public randomWordsTest;
    uint256 public s_requestId;

    /* Variables */
    // TODO: Optimize space by making contiguous (256 bits)
    uint public buyLimit;
    uint public timeInterval;
    uint public startTime;
    uint public endTime;
    uint32 public totalTickets;
    address public owner;
    bool internal locked;
    mapping(address => uint) public balances;
    mapping(address => uint) public ticketBalances;
    address[] public participants;

    enum State {Ready, Running, Canceled}
    State public poolState;

    /* Events */
    event StartPoolEvent(address sender, uint startTime, uint endTime);
    event BuyTicketEvent(address sender, uint amtTickets);
    event DistributePoolEvent(address sender, uint poolManagementFee, uint poolUnlockFee, uint poolPrize);
    event WithDrawEvent(address sender, uint owedFunds);

    /* Modifiers */ 
    modifier reentrancyGuard() {
        require(!locked, "The reetrancy guard has been triggered. Please try calling the function again.");
        locked = true;
        _;
        locked = false;
    }
    
    modifier poolOpen() {
        require(endTime >= block.timestamp, "The pool has not closed yet");
        _;
    }
    
    modifier poolClosed() {
        require(endTime < block.timestamp, "The pool has closed");
        _;
    } 

    modifier onlyOwner() {
        require(msg.sender == owner, "Only the owner can call this function");
        _;
    }

    /* Constructor */
    constructor(address _sender, uint _buyLimit, uint _timeInterval, uint64 _subscriptionId) VRFConsumerBaseV2(vrfCoordinator) {
        // VRF 
        COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
        s_subscriptionId = _subscriptionId;

        // Pool
        owner = _sender;
        buyLimit = _buyLimit;
        timeInterval = _timeInterval;        
        poolState = State.Ready;
    }

    /* VRF Functions */
    // TODO: Optimize for less queries
    function requestRandomNumbers() public poolClosed {
        require(poolState == State.Running, "Pool must be in the running state");
        require(s_randomWords.length == 0, "Must populate random values first");

        uint32 callbackGasLimit = totalTickets * 20000; // 20000 per word is reasonable
        s_requestId = COORDINATOR.requestRandomWords(
            keyHash,
            s_subscriptionId,
            requestConfirmations,
            callbackGasLimit,
            totalTickets
        );
    }

    // Get random values and do something with them
    function fulfillRandomWords(
        uint256,
        uint256[] memory randomWords
    ) internal override {
        for (uint i = 0; i < randomWords.length; i++) {
            randomWords[i] = (randomWords[i] % 100) + 1; // Number from 1 to 100
        }
        s_randomWords = randomWords;
    }

    /* Functions */
    // Start running the pool
    function startPool() public onlyOwner {
        require(poolState == State.Ready, "Pool must be in the ready state");
        startTime = block.timestamp;
        endTime = startTime + timeInterval;
        poolState = State.Running;

        emit StartPoolEvent(msg.sender, startTime, endTime);
    }

    // Allow a user to buy a ticket
    function buyTicket() payable external poolOpen {
        require(poolState == State.Running, "Pool must be in the running state");
        require(msg.value >= buyLimit, "User must purchase tickets above the buying limit");
        require((msg.value % buyLimit) == 0, "User must purchase tickets at a multiple of the buy limit");

        // Add user to participants if first time buying ticket
        if (ticketBalances[msg.sender] == 0) {
            participants.push(msg.sender);
        }

        // TODO: Clean up types -> int32 casting
        // Get total amount of tickets
        uint amtTickets = msg.value / buyLimit;

        // Increase ticket count for address
        ticketBalances[msg.sender] += amtTickets;
        totalTickets += uint32(amtTickets);

        emit BuyTicketEvent(msg.sender, amtTickets);
    }
    
    // Distribute funds in pool to all ticket holders
    function distributePool() public poolClosed {
        require(poolState == State.Running, "Pool must be in the running state");
        require(s_randomWords.length != 0, "Must populate random values first");
        address ticketOwner;

        // Allocate pool fees and prize
        // https://stackoverflow.com/questions/68310368/how-to-calculate-percentage-in-solidity
        uint poolBalance = address(this).balance;
        uint poolManagementFee = percentage(poolBalance, 3);
        uint poolUnlockFee = percentage(poolBalance, 1);
        uint poolPrize = percentage(poolBalance, 95);
        
        poolState = State.Ready;
        balances[msg.sender] += poolUnlockFee;

        // Distribute funds from pool to each participant
        // TODO: iterate over amt of tickets per user

        // Iterate randomWordsIdx by 1 every 200th iteration to avoid O(N^2) for loop
        // uint randomWordsIdx = 0;
        // uint randomWordsVal = 0;
        // uint probability = 0;
        // uint poolShare = 0;
        // for (uint i = 0; i < totalTickets; i++) {
        //     if (totalTickets % 200 == 0) {
        //         randomWordsIdx += 1;
        //         randomWordsVal = s_randomWords[randomWordsIdx];
        //         shiftIdx = 0;
        //     }
        //     
        //     probability = ((randomWordsVal >> shiftIdx) % 100) + 1; // Number from 1 to 100
        //     poolShare = percentage(poolPrize, probability);
        //     balances[ticketOwner] += poolShare;
        //     shiftIdx += 1;
        // }
      
        for (uint idx = 0; idx < participants.length; idx++) {
            ticketOwner = participants[idx];
            balances[ticketOwner] += percentage(poolPrize, s_randomWords[idx]);
            // balances[ticketOwner] = randomized probabilty * value * use -> need chainlink VRF here
            delete ticketBalances[ticketOwner]; 
        }

        // Clear participants 
        delete participants;

        // Clear random values
        delete s_randomWords;

        // Clear tickets
        delete totalTickets;

        emit DistributePoolEvent(msg.sender, poolManagementFee, poolUnlockFee, poolPrize);
    }

    // Withdrawl all owed funds stored in balances
    function withdraw() payable external reentrancyGuard {
        uint owedFunds = balances[msg.sender];
        balances[msg.sender] = 0;
        (bool sent, bytes memory data) = msg.sender.call{value: owedFunds}("");
        require(sent, "Failed to send ether...");
        emit WithDrawEvent(msg.sender, owedFunds);
    }

    /* Emergency Functions */
    // Stop the pool in case of an emergency
    function emergencyStop() public onlyOwner {
        poolState = State.Canceled;
        address ticketOwner;

        // Give all funds back to users who purchased tickets in pool
        for (uint idx = 0; idx < participants.length; idx++) {
            ticketOwner = participants[idx];
            balances[ticketOwner] += ticketBalances[ticketOwner] * buyLimit;
            delete ticketBalances[ticketOwner]; 
        }
        // Clear participants
        delete participants;
        delete totalTickets;
    }

    // Move pool out of emergency state and back to ready
    function emergencyReset() public onlyOwner {
        require(poolState == State.Canceled, "Pool must be in the canceled state");
        poolState = State.Ready;
    }

    /* Utility Functions */
    function percentage(uint value, uint pct) internal pure returns (uint256) {
        return (value / 100) * pct;
    }

    /* Getter and Setter Functions*/
    function getContractBalance() external view returns (uint) {
        return address(this).balance;
    }

    function getTicketBalance() external view returns (uint) {
        return ticketBalances[msg.sender];
    }

    function getBalance() external view returns (uint) {
        return balances[msg.sender];
    }

    function getPoolRunning() external view returns (bool) {
        return endTime >= block.timestamp;
    }

    // Function to receive Ether. msg.data must be empty
    receive() external payable {} 

    // Fallback function is called when msg.data is not empty
    fallback() external payable {}
}